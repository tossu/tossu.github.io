<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2 data-id="code-title">Spring</h2>
        </section>

        <section>
          <h3>Mik√§ on papu? ü´ò</h3>
          Bean on mik√§ tahansa Java-olio, jota Spring hallinnoi. Jos Spring luo
          sen, injektoi sen ja hallitsee sen elinkaarta, kyseess√§ on papu.
        </section>

        <section>
          <h3>Pavun el√§m√§nteht√§v√§</h3>
          <pre><strong>Riippuvuuksien injektointi (Dependency Injection)</strong>
Spring rakentaa olioverkon puolestasi. (@Autowired)</pre>

          <pre><strong>V√§lj√§ kytkent√§ (Loose coupling)</strong>
Luokat riippuvat rajapinnoista, eiv√§t konkreettisista toteutuksista.
Tehd√§√§n yksi asia ja pyrit√§√§n v√§ltt√§m√§√§n suoraa riippuvuutta.</pre>

          <pre><strong>Keskitetty elinkaaren hallinta</strong>
Luonti, tuhoaminen, proxyt, transaktiot jne.</pre>
        </section>

        <section>
          <h3>Elinkaari (@scope)</h3>
          <pre>singleton - yksi instanssi (default)</pre>
          <pre>
prototype - yksi instanssi per k√§ytt√∂ (injection), 
            eli uusi instanssi joka kerta kun ladataan</pre
          >
          <pre>request - yksi instanssi per HTTP-pyynt√∂ (web apps)</pre>
          <pre>session - yksi instanssi per HTTP-session</pre>
        </section>

        <section>
          <h3>Perus annotaatiot</h3>

<pre>
<code>@Component</code>
Merkitsee luokan Spring-hallinnoiduksi paavuksi.
</pre>

<pre>
<code>@Service</code>
Sama kuin @Component, mutta semanttisesti liiketoimintalogiikalle.
</pre>

<pre>
<code>@Repository</code>
Sama idea, datak√§ytt√∂kerroksia varten. Mahdollistaa my√∂s poikkeuksien k√§√§nn√∂ksen.
</pre>

<pre>
<code>@Autowired</code>
Injektoi riippuvuudet tyypin mukaan.
</pre>

<pre>
<code>@Qualifier("beanName")</code>
Selvent√§√§, mik√§ papu tulee injektoida.
</pre>

<pre>
<code>@Value("${property.name}")</code>
Injektoi arvot konfiguraatiosta.
</pre>
        </section>

        <section>
          <h3>Perus annotaatiot</h3>

<pre>
<code>@Configuration</code>
Merkitsee luokkaa bean-m√§√§ritysten l√§hteeksi.
</pre>

<pre>
<code>@Bean</code>
M√§√§rittelee beanin.
</pre>

<pre>
<code>@Profile("dev")</code>
Lataa beanit vain tietyille ymp√§rist√∂ille.
</pre>

<pre>
<code>@Primary</code>
Tekee beaanista oletusvalinnan, kun useita kandidaatteja on.
</pre>
        </section>

        <section>
          <h3>Perus annotaatiot</h3>

          <pre>
<code>@RestController</code>
Kontrolleri, jossa metodit palauttavat JSONia/XML:√§√§ suoraan, eli API -endpointit.
</pre>

          <pre>
<code>@Controller</code>
MVC-kontrolleri n√§kymille (HTML-mallipohjat).
</pre>

          <pre>
<code>@RequestMapping("/api")</code>
Peruspolun m√§√§rittely.
</pre>

          <pre>
<code>@GetMapping, @PostMapping, @PutMapping, @DeleteMapping</code>
HTTP-metodikohtaiset kartoittajat.
</pre>

          <pre>
<code>@RequestParam, @PathVariable, @RequestBody</code>
Sidokset pyynn√∂n tietoihin metodiparametreilla.
</pre>

          <pre>
<code>@MockBean</code>
Injektoi mokkeja Spring-kontekstiin.
</pre>
        </section>

        <section>
          <h3>Luonti</h3>

          <pre>
						<code>
  @Component
  class MyComponent {}
					</code>
				</pre>

          <pre><code>
  @Configuration
  @Profile("dev")
  class DevConfig {

      @Value("${app.greeting}")
      private String greeting;

      @Bean
      public MyService myService() {
          return new MyService(greeting);
      }
  }
				</code></pre>
        </section>

        <section>
          <h3>Lataus j√§rjestys</h3>

						<pre>
						<code>@DependsOn("seppoService")</code>
						Bean A ennen Bean B, joku siis vaatii seppoServicen toimiakseen
						</pre>

											<pre>
						<code>@Primary</code>
						Yksi oletusimplementaatio, jos useita toteutuksia on, t√§m√§ valitaan
						</pre>

						<pre>
						<code>@Qualifier</code>
						Tarkka bean, m√§√§rittelee tarkasti k√§ytett√§v√§n pavun

						<code>
  @Autowired
  @Qualifier("seppoFormatter")
  private Formatter formatter;
						</code>
						</pre>

						<pre>
						<code>@Lazy</code>
						Laiska lataus, ladataan kun tarvitaan, voidaan v√§ltt√§√§ "circular dependencies" -virheit√§
						</pre>


        </section>

				<section>
												<pre>
						J√§rjestetty lista beaneja, @Order m√§√§ritt√§√§ j√§rjestyksen
						<code>
@Component
@Order(1)
class A extends Seppo {
    public String getName() {
        return "A";
    }
}
						</code>
						<code>
@Component
@Order(2)
class B extends Seppo {
    public String getName() {
        return "B";
    }
}
						</code>
						<code>
@Autowired
List&lt;Seppo&gt; sepot;
</code>
						</pre>
				</section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
